# A0127483B
###### src/fini/main/Brain.java
``` java
 */

```
###### src/fini/main/Brain.java
``` java
    /* ***********************************
     * Fields
     * ***********************************/
    // Singleton
    private static Brain brain;
    private DisplayController displayController;

    /**
     * DisplayControllerStub for test purpose
     */
    //    private DisplayControllerStub displayController;

    private Storage taskOrganiser;
    private FiniParser finiParser;
    private Sorter sorter;
    private StatusSaver statusSaver;

    private ArrayList<Task> taskMasterList;
    private ObservableList<String> projectNameList = FXCollections.observableArrayList(); 
    private ObservableList<Task> taskObservableList = FXCollections.observableArrayList();
    private ObservableList<Task> taskAuxiliaryList = FXCollections.observableArrayList(); 

    private boolean searchDisplayTrigger = false;
    private boolean projectDisplayTrigger = false;
    private boolean completeDisplayTrigger = false;
    private boolean allDisplayTrigger = false;

    /* ***********************************
     * Private Constructor
     * ***********************************/
    private Brain() {
        finiParser = FiniParser.getInstance();
        taskOrganiser = Storage.getInstance();
        statusSaver = StatusSaver.getInstance();

        taskMasterList = taskOrganiser.readFile();
        sortTaskMasterList();
        taskObservableList.setAll(getIncompleteTasks());
        taskAuxiliaryList.setAll(taskObservableList); 

        for (Task task : taskAuxiliaryList) {
            if (!task.getProjectName().equals(DEFAULT_PROJECT) && !projectNameList.contains(task.getProjectName())) {
                projectNameList.add(task.getProjectName());
            }
        }
        statusSaver.saveStatus(taskMasterList, taskObservableList);
    }

    /*
     * This method is the getInstance method for the singleton pattern of
     * Brain. It initialises a new Brain if Brain is null, else returns the
     * current instance of the Brain.
     */
    public static Brain getInstance() {
        if (brain == null) {
            brain = new Brain();
        }
        return brain;
    }

    /*
     * This method initialises the first display when FINI is launched
     * This method is executed from the MainApp
     */ 
    public void initDisplay() {
        displayController.setFocusToCommandBox();
        displayController.updateMainDisplay(taskAuxiliaryList);
        displayController.updateProjectsOverviewPanel(projectNameList);
        displayController.updateTasksOverviewPanel(taskAuxiliaryList);
        displayController.updateFiniPoints(getCompletedTasks());
    }

    /* ***********************************
     * Public execution method
     * ***********************************/
```
###### src/fini/main/Brain.java
``` java
    private String addTask(String commandParameters) {
        if (commandParameters.isEmpty()) {
            return ADD_EMPTY_PARAMETER;
        }

        finiParser.parse(commandParameters);

        if (finiParser.getDatetimes() != null && finiParser.getDatetimes().size() == 2 &&
                !finiParser.getDatetimes().get(START_INDEX).isBefore(finiParser.getDatetimes().get(END_INDEX))) {
            return START_EXCEEDS_END;
        }

        if (!finiParser.getProjectName().equals(DEFAULT_PROJECT) &&
                !projectNameList.contains(finiParser.getProjectName()) &&
                projectNameList.size() == MAXIMUM_NUM_OF_PROJECTS) {
            return EXCEEDS_PROJECT_LIMIT;
        }

        Task newTask = new Task.TaskBuilder(finiParser.getNotParsed(), finiParser.getIsRecurring())
                .setDatetimes(finiParser.getDatetimes())
                .setPriority(finiParser.getPriority())
                .setProjectName(finiParser.getProjectName())
                .setInterval(finiParser.getInterval())
                .setRecursUntil(finiParser.getRecursUntil()).build();

        taskMasterList.add(newTask);
        taskOrganiser.updateFile(taskMasterList);
        return String.format(ADD_MESSAGE, finiParser.getNotParsed());
    }

    private String updateTask(int objectIndex, String commandParameters) {
        Task taskToUpdate;

        if (commandParameters.isEmpty()) {
            return UPDATE_EMPTY_PARAMETER;
        }

        try {
            taskToUpdate = taskObservableList.get(objectIndex - 1);
        } catch (IndexOutOfBoundsException e) {
            return TASK_NOT_FOUND;
        }

        // delete first
        taskObservableList.remove(taskToUpdate);
        taskMasterList.remove(taskToUpdate);
        taskOrganiser.updateFile(taskMasterList);

        // add then
        finiParser.parse(commandParameters);

        if (finiParser.getDatetimes() != null && finiParser.getDatetimes().size() == 2 &&
                !finiParser.getDatetimes().get(START_INDEX).isBefore(finiParser.getDatetimes().get(END_INDEX))) {
            return START_EXCEEDS_END;
        }

        if (!finiParser.getProjectName().equals(DEFAULT_PROJECT) &&
                !projectNameList.contains(finiParser.getProjectName()) &&
                projectNameList.size() == MAXIMUM_NUM_OF_PROJECTS) {
            return EXCEEDS_PROJECT_LIMIT;
        }

        Task newTask = new Task.TaskBuilder(finiParser.getNotParsed(), finiParser.getIsRecurring())
                .setDatetimes(finiParser.getDatetimes())
                .setPriority(finiParser.getPriority())
                .setProjectName(finiParser.getProjectName())
                .setInterval(finiParser.getInterval())
                .setRecursUntil(finiParser.getRecursUntil()).build();

        taskMasterList.add(newTask);
        taskOrganiser.updateFile(taskMasterList);

        return String.format(UPDATE_MESSAGE, objectIndex, taskToUpdate.getTitle());
    }

    private String deleteTask(int objectIndex) {
        Task taskToDelete;
        try {
            taskToDelete = taskObservableList.get(objectIndex - 1);
        } catch (IndexOutOfBoundsException e) {
            return TASK_NOT_FOUND;
        }

        taskObservableList.remove(taskToDelete);
        taskMasterList.remove(taskToDelete);
        taskOrganiser.updateFile(taskMasterList);
        return String.format(DELETE_MESSAGE, objectIndex, taskToDelete.getTitle());
    }

```
###### src/fini/main/model/FiniParser.java
``` java
 */
public class FiniParser {
    /* ***********************************
     * Constants
     * ***********************************/
    private static final String[] REDUNDANT_WORDS = {"on", "from", "by"};
    private static final String[] NUM_WITHIN_TEN = {"one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten"};
    private static final String DEFAULT_PROJECT = "Inbox";
    private static final String ONE_SPACE = " ";
    private static final String ONE_OR_MORE_SPACE = "\\s+";
    private static final String EMPTY_STRING = "";
    private static final String PARSE_SUCCESS = "FiniParser.parse SUCCESS";
    private static final String PARSE_FAIL = "FiniParser.parse ERROR";
    
    /* ***********************************
     * Fields
     * ***********************************/
    // Singleton
    private static FiniParser finiParser;
    private Parser parser;

    private String cleanParameters;
    private Priority priority;
    private String projectName;
    private ArrayList<LocalDateTime> datetimes;
    private boolean recurFlag;
    private boolean isRecurring;
    private LocalDateTime recursUntil;
    private Period interval;
    private String notParsed;

    /* ***********************************
     * Private constructor
     * ***********************************/
    private FiniParser() {
        initializeFields();
    }
    
    // getInstance method
    public static FiniParser getInstance() {
        if (finiParser == null) {
            finiParser = new FiniParser();
        }
        return finiParser;
    }

    /* ***********************************
     * Public parsing method
     * ***********************************/    
    public String parse(String commandParameters) {
        try {
            initializeFields();
            cleanParameters = getSimpleCleanString(commandParameters); // init of clean

            String[] splitParameters = cleanParameters.split(ONE_SPACE);
            determinePriority(splitParameters);
            determineProjectName(splitParameters);
            notParsed = determineDatetimes(cleanParameters);
            notParsed = eliminateRedundantWords(notParsed);
            
            MainApp.finiLogger.info("Clean parameters: " + cleanParameters);
            MainApp.finiLogger.info("Not parsed words: " + notParsed);
            
            return PARSE_SUCCESS;
        } catch (Exception e) {
            e.printStackTrace();
            return PARSE_FAIL;
        }
    }

    /* ***********************************
     * Private method
     * ***********************************/    
    private void determinePriority(String[] splitParameters) {
        List<String> words = Arrays.asList(splitParameters);
        for (String word : words) {
            if (word.toLowerCase().equals("priority")) {
                if (words.indexOf(word) != words.size() - 1) {
                    String priorityString = words.get(words.indexOf(word) + 1);
                    Priority returnPriority;
                    switch (priorityString.toLowerCase()) {
                        case "high":
                            returnPriority = Priority.HIGH;
                            break;
                        case "medium":
                            returnPriority = Priority.MEDIUM;
                            break;
                        case "low":
                            returnPriority = Priority.LOW;
                            break;
                        default:
                            returnPriority = Priority.NORMAL;
                            break;
                    }

                    if (!returnPriority.equals(Priority.NORMAL)) {
                        cleanParameters = cleanParameters.replaceAll(word + ONE_SPACE + priorityString, EMPTY_STRING);
                        cleanParameters = getSimpleCleanString(cleanParameters);
                        priority = returnPriority;
                        break;
                    }
                } else {
                    // "priority" keyword appears at the end
                    break;
                }
            }
        }
    }

    private void determineProjectName(String[] splitParameters) {
        List<String> words = Arrays.asList(splitParameters);
        for (String word : words) {
            if (word.toLowerCase().equals("project")) {
                if (words.indexOf(word) != words.size() - 1) {
                    String projectString = words.get(words.indexOf(word) + 1);
                    cleanParameters = cleanParameters.replaceAll(word + ONE_SPACE + projectString, EMPTY_STRING);
                    cleanParameters = getSimpleCleanString(cleanParameters);
                    projectName = projectString;
                } else {
                    // "project" keyword appears at the end
                    break;
                }
            }
        }
    }

    /**
     * Extract date time information out of parameters.
     * With the help of Natty's interpretation, our parser can evaluation various date time format.
     * 
     * Since we build a recur evaluator out of Natty and yet Natty is not able to handle recurring event correctly as we expected.
     * This method split the parameters with keyword "repeat" and parse the segments before and after REPEAT accordingly.
     * 
     * Notice that the order of evaluation goes this way:
     * recur starting datetime -> repeat keyword -> interval & recurs until
     * If anything at higher order is not satisfied, the recurs condition is not valid.
     * A null interval or default interval will be set to recur interval.
     * An endless recur may be set for recursUntil.
     * 
     * @param cleanParameters
     * @return cleaned notParsed string
     */
    private String determineDatetimes(String cleanParameters) {
        if (cleanParameters.contains("repeat")) {
            String[] splitParameters = cleanParameters.split("repeat");
            if (splitParameters.length == 2) {
                notParsed = processFrontPart(getSimpleCleanString(splitParameters[0])) + ONE_SPACE + processBackPart(getSimpleCleanString(splitParameters[1]));
            } else {
                notParsed = processFrontPart(getSimpleCleanString(splitParameters[0]));
            }
        } else {
            notParsed = processFrontPart(cleanParameters);
        }
        return getSimpleCleanString(notParsed);
    }

    /* ***********************************
     * Public getters
     * ***********************************/
    public String getCleanParameters() {
        return cleanParameters;
    }

    public Priority getPriority() {
        return priority;
    }

    public String getProjectName() {
        return projectName;
    }

    public ArrayList<LocalDateTime> getDatetimes() {
        assert datetimes != null;
        return datetimes;
    }

    public boolean getIsRecurring() {
        return isRecurring;
    }

    public LocalDateTime getRecursUntil() {
        return recursUntil;
    }

    public Period getInterval() {
        return interval;
    }

    public String getNotParsed() {
        return notParsed;
    }

    /* ***********************************
     * Utility method
     * ***********************************/
    private String getSimpleCleanString(String input) {
        return input.trim().replaceAll(ONE_OR_MORE_SPACE, ONE_SPACE);
    }
    
    /**
     * Extract recur interval and recur limit (recursUntil) out of parameters after REPEAT keyword
     * 
     * Possible situations (in example format):
     * Single interval unit with no recurs until -> every week / everyday
     * Single interval unit with recurs until -> every week until dec
     * Multiple interval units with no recurs until -> every two months
     * Multiple interval units with until -> every two weeks until dec
     * 
     * The reason we split so many situations is that, Natty although accept recurring datetime, it parses recur very differently.
     * Sometimes it will go against our original purpose. The details of how it violate our purpose are omitted here.
     * 
     * P.S.
     * A recurring task require at least two elements
     * 1. Recur starting point
     * 2. Recur interval
     * (3. Recur limit)
     * This is the main reason we require users to input STARTING TIME before REPEAT and followed by INTERVAL and RECURSUNTIL
     * 
     * As for interval unit, we regard 'day', 'week', 'month', 'year' as single unit which cannot be split down into smaller components,
     * whereas 'two weeks', 'three months' are multiple interval units.
     * Whichever interval format is goes, the interval is always a constant value.
     * Intervals like 'every monday to friday' are not allowed in FINI.
     * 
     * @param parameters
     * @return notParsed parameters after REPEAT keyword
     */
    private String processBackPart(String parameters) {
        if (recurFlag) {
            isRecurring = true;
        } else {
            return parameters;
        }
        List<DateGroup> groups = parser.parse(parameters);
        if (!parameters.startsWith("every")) {
            interval = Period.ofDays(1);
            return parameters;
        }

        String returnNotParsed = EMPTY_STRING;
        if (groups.size() == 0) {
            returnNotParsed = singleIntervalUnitWithNoUntil(parameters);
        } else if (groups.size() == 1 && parameters.contains("until") && !groups.get(0).isRecurring()) {
            returnNotParsed = singleIntervalUnitWithUntil(parameters, groups.get(0));
        } else if (groups.size() == 1 && !parameters.contains("until") && groups.get(0).isRecurring()) {
            returnNotParsed = multipleIntervalUnitsWithNoUntil(parameters);
        } else if (groups.size() == 1 && parameters.contains("until") && groups.get(0).isRecurring()) {
            returnNotParsed = multipleIntervalUnitsWithUntil(parameters, groups.get(0));
        } else {
         // default: everyday endlessly
            interval = Period.ofDays(1);
        }
        return returnNotParsed;
    }

    private String multipleIntervalUnitsWithUntil(String parameters, DateGroup group) {
        recursUntil = LocalDateTime.ofInstant(group.getRecursUntil().toInstant(), ZoneId.systemDefault());
        String returnNotParsed = parameters;
        String[] splitParameters = parameters.split(ONE_SPACE);
        if (isValidNumbering(splitParameters[1]) && isIntervalUnits(splitParameters[2])) {
            interval = determineIntervalUnits(splitParameters[1], splitParameters[2]);
            returnNotParsed = returnNotParsed.replaceAll("every " + splitParameters[1] + ONE_SPACE + splitParameters[2], EMPTY_STRING);
        } else {
            interval = Period.ofDays(1);
        }
        return returnNotParsed;
    }

    private String multipleIntervalUnitsWithNoUntil(String parameters) {
        String returnNotParsed = parameters;
        String[] splitParameters = parameters.split(ONE_SPACE);
        if (splitParameters[0].equals("every") && isValidNumbering(splitParameters[1]) && isIntervalUnits(splitParameters[2])) {
            interval = determineIntervalUnits(splitParameters[1], splitParameters[2]);
            returnNotParsed = returnNotParsed.replaceAll(splitParameters[0] + ONE_SPACE + splitParameters[1] + ONE_SPACE + splitParameters[2], EMPTY_STRING);
        } else {
            interval = Period.ofDays(1);
        }
        return returnNotParsed;
    }

    private String singleIntervalUnitWithUntil(String parameters, DateGroup group) {
        String returnNotParsed = parameters;
        recursUntil = LocalDateTime.ofInstant(group.getDates().get(0).toInstant(), ZoneId.systemDefault());
        String[] splitParameters = parameters.split(ONE_SPACE);
        if (parameters.startsWith("everyday")) {
            interval = Period.ofDays(1);
            returnNotParsed = returnNotParsed.replaceAll("everyday", EMPTY_STRING);
        } else if (splitParameters[0].equals("every") && isIntervalUnit(splitParameters[1])) {
            interval = determineIntervalUnit(splitParameters[1]);
            returnNotParsed = returnNotParsed.replaceAll("every", EMPTY_STRING);
            returnNotParsed = returnNotParsed.replaceAll(splitParameters[1], EMPTY_STRING);
        }
        returnNotParsed = returnNotParsed.replaceAll("until", EMPTY_STRING);
        returnNotParsed = returnNotParsed.replaceAll(group.getText(), EMPTY_STRING);
        return returnNotParsed;
    }

    private String singleIntervalUnitWithNoUntil(String parameters) {
        String returnNotParsed = parameters;
        String[] splitParameters = parameters.split(ONE_SPACE);
        if (parameters.startsWith("everyday")) {
            interval = Period.ofDays(1);
            returnNotParsed = returnNotParsed.replaceAll("everyday", EMPTY_STRING);
        } else if (splitParameters[0].equals("every") && isIntervalUnit(splitParameters[1])) {
            interval = determineIntervalUnit(splitParameters[1]);
            returnNotParsed = returnNotParsed.replaceAll("every", EMPTY_STRING);
            returnNotParsed = returnNotParsed.replaceAll(splitParameters[1], EMPTY_STRING);
        }
        return returnNotParsed;
    }

    private Period determineIntervalUnits(String numbering, String word) {
        int number = 0;
        for (int i = 0; i < NUM_WITHIN_TEN.length; ++i) {
            if (NUM_WITHIN_TEN[i].equals(numbering)) {
                number = i + 1;
                break;
            }
        }

        if (number == 0) {
            try {
                number = Integer.parseInt(numbering);
            } catch (NumberFormatException e) {
                e.printStackTrace();
            }
        }

        switch (word) {
            case "days":
                return Period.ofDays(number);
            case "weeks":
                return Period.ofWeeks(number);
            case "months":
                return Period.ofMonths(number);
            case "years":
                return Period.ofYears(number);
            default:
                return Period.ofDays(1);
        }
    }

    private Period determineIntervalUnit(String word) {
        switch (word) {
            case "day":
                return Period.ofDays(1);
            case "week":
                return Period.ofWeeks(1);
            case "month":
                return Period.ofMonths(1);
            case "year":
                return Period.ofYears(1);
            default:
                return Period.ofDays(1);
        }
    }

    private boolean isValidNumbering(String word) {
        for (String num : NUM_WITHIN_TEN) {
            if (word.equals(num)) {
                return true;
            }
        }

        try {
            Integer.parseInt(word);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    private boolean isIntervalUnits(String word) {
        return word.equals("days") || word.equals("weeks") || word.equals("months") || word.equals("years");
    }

    private boolean isIntervalUnit(String word) {
        return word.equals("day") || word.equals("week") || word.equals("month") || word.equals("year");
    }

    /**
     * Extract starting datetime out of the front part if REPEAT exists, the entire string if REPEAT is absent.
     * 
     * If only date is given, it is very likely that the user is expecting a 2359 as a time.
     * 
     * @param parameters
     * @return notParsed parameters before keyword REPEAT or notParsed parameters of the whole string
     */
    private String processFrontPart(String parameters) {
        List<DateGroup> groups = parser.parse(parameters);

        if (groups.size() == 0) {
            recurFlag = false;
            return getSimpleCleanString(parameters);
        } else {
            DateGroup group = groups.get(0);
            List<Date> dateList = group.getDates(); 
            Map<String, List<ParseLocation>> parseMap = group.getParseLocations();
            if (!parseMap.containsKey("explicit_time")) {
                for (Date date : dateList) {
                    LocalDateTime temp = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
                    datetimes.add(LocalDateTime.of(temp.toLocalDate(), LocalTime.MAX));
                }
            } else {
                for (Date date : dateList) {
                    datetimes.add(LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()));
                }
            }
            String returnNotParsed = parameters;
            for (ParseLocation parsedWord : parseMap.get("parse")) {
                returnNotParsed = returnNotParsed.substring(0, parsedWord.getStart() - 1) + returnNotParsed.substring(parsedWord.getEnd() - 1);
            }
            return getSimpleCleanString(returnNotParsed);
        }
    }

    private String eliminateRedundantWords(String notParsed) {
        String cleanString = EMPTY_STRING;
        ArrayList<String> splitCleanString = new ArrayList<String>(Arrays.asList(notParsed.split(ONE_SPACE)));
        for (String word : REDUNDANT_WORDS) {
            while (splitCleanString.contains(word)) {
                int removeIndex = splitCleanString.indexOf(word);
                splitCleanString.set(removeIndex, EMPTY_STRING);
            }
        }
        for (String word : splitCleanString) {
            cleanString += word + ONE_SPACE;
        }
        return getSimpleCleanString(cleanString);
    }

    /* ***********************************
     * Initialization method
     * ***********************************/
    private void initializeFields() {
        parser = new Parser();
        cleanParameters = EMPTY_STRING;
        priority = Priority.NORMAL;
        projectName = DEFAULT_PROJECT;
        datetimes = new ArrayList<LocalDateTime>();
        recurFlag = true;
        isRecurring = false;
        recursUntil = null;
        interval = null;
        notParsed = EMPTY_STRING;
    }
}
```
###### src/fini/main/model/StatusSaver.java
``` java
package fini.main.model;

import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.Stack;

import fini.main.MainApp;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

/**
 * This class handles the saving of past status of the application
 * Mainly for UNDO and REDO (possibly) functions
 * 
 */
public class StatusSaver {
    /* ***********************************
     * Fields
     * ***********************************/
    // Singleton
    private static StatusSaver statusSaver;

    private Stack<ArrayList<Task>> undoMasterStack;
    private Stack<ObservableList<Task>> undoObservableStack;

    private Stack<ArrayList<Task>> redoMasterStack;
    private Stack<ObservableList<Task>> redoObservableStack;

    private ArrayList<Task> tempTaskMasterList;
    private ObservableList<Task> tempTaskObservableList;

    /* ***********************************
     * Private constructor
     * ***********************************/
    private StatusSaver() {
        undoMasterStack = new Stack<ArrayList<Task>>();
        undoObservableStack = new Stack<ObservableList<Task>>();
        redoMasterStack = new Stack<ArrayList<Task>>();
        redoObservableStack = new Stack<ObservableList<Task>>();
    }
    
    // getInstance method
    public static StatusSaver getInstance() {
        if (statusSaver == null) {
            statusSaver = new StatusSaver();
        }
        return statusSaver;
    }

    /* ***********************************
     * Public methods
     * ***********************************/
    public void saveStatus(ArrayList<Task> taskMasterList, ObservableList<Task> taskObservableList) {
        MainApp.finiLogger.info("Undo stack size before save: " + undoMasterStack.size());
        MainApp.finiLogger.info("Redo stack size before save: " + redoMasterStack.size());
        
        undoMasterStack.push(copyArrayList(taskMasterList));
        undoObservableStack.push(copyObservableList(taskObservableList));
        redoMasterStack.clear();
        redoObservableStack.clear();
        
        MainApp.finiLogger.info("Undo stack size after save: " + undoMasterStack.size());
        MainApp.finiLogger.info("Redo stack size after save: " + redoMasterStack.size());
    }

    public void retrieveLastStatus() {
        MainApp.finiLogger.info("Undo stack size before retrieve undo: " + undoMasterStack.size());
        MainApp.finiLogger.info("Redo stack size before retrieve undo: " + redoMasterStack.size());
        
        try {
            redoMasterStack.push(copyArrayList(undoMasterStack.pop()));
            redoObservableStack.push(copyObservableList(undoObservableStack.pop()));

            tempTaskMasterList = copyArrayList(undoMasterStack.peek());
            tempTaskObservableList = copyObservableList(undoObservableStack.peek());
        } catch (EmptyStackException e) {
            e.printStackTrace();
        }
        
        MainApp.finiLogger.info("Undo stack size after retrieve undo: " + undoMasterStack.size());
        MainApp.finiLogger.info("Redo stack size after retrieve undo: " + redoMasterStack.size());
    }

    public void retrieveRedoStatus() {
        MainApp.finiLogger.info("Undo stack size before retrieve redo: " + undoMasterStack.size());
        MainApp.finiLogger.info("Redo stack size before retrieve redo: " + redoMasterStack.size());
        
        try {
            tempTaskMasterList = redoMasterStack.pop();
            tempTaskObservableList = redoObservableStack.pop();

            undoMasterStack.push(copyArrayList(tempTaskMasterList));
            undoObservableStack.push(copyObservableList(tempTaskObservableList));
        } catch (EmptyStackException e) {
            e.printStackTrace();
        }
        
        MainApp.finiLogger.info("Undo stack size after retrieve redo: " + undoMasterStack.size());
        MainApp.finiLogger.info("Redo stack size after retrieve redo: " + redoMasterStack.size());
    }

    /* ***********************************
     * Public getters
     * ***********************************/
    public ArrayList<Task> getLastTaskMasterList() {
        assert tempTaskMasterList != null;
        return tempTaskMasterList;
    }

    public ObservableList<Task> getLastTaskObservableList() {
        assert tempTaskObservableList != null;
        return tempTaskObservableList;
    }
    
    public boolean isUndoMasterStackEmpty() {
        return undoMasterStack.size() == 1;
    }

    public boolean isRedoMasterStackEmpty() {
        return redoMasterStack.isEmpty();
    }

    public int getUndoMasterStackSize() {
        return undoMasterStack.size();
    }

    public int getRedoMasterStackSize() {
        return redoMasterStack.size();
    }
    
    /* ***********************************
     * Utility methods
     * ***********************************/
```
###### src/fini/main/model/Storage.java
``` java
package fini.main.model;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;

import fini.main.MainApp;

/**
 * Storage component (which is instantiated as taskOrganiser in Brain) takes charge in saving and retrieving of tasks
 * It makes use of google json library - Gson
 * to solidate tasks into readable text format.
 * 
 * A Java serialization library that can convert Java Objects into JSON and back
 * https://github.com/google/gson
 * 
 * There are total three files that Storage will hand on.
 * save.txt -> Main save file, when the user preferred file is not found, it acts like a back up file
 * config.txt -> Store the directory of user preferred file
 * user preferred file (Fini_untitled.txt) -> user preferred saving file, Storage will access this file first
 * Notice that user preferred file must be created before the path is set.
 */
public class Storage {
    /* ***********************************
     * Constants
     * ***********************************/
    private static final String SAVE_FILE_NAME = "save.txt";
    private static final String CONFIG_FILE_NAME = "config.txt";
    private static final String DEFAULT_USER_PREF_NAME = "Fini_untitled.txt";
    
    private static final String SAME_DIRECTORY_MESSAGE = "Same file directory";
    private static final String SET_SUCCESS_MESSAGE = "The directory is set";
    private static final String SET_FAIL_MESSAGE = "No such file";
    private static final String EMPTY_STRING = "";
    
    private static final String FILE_ENCODING_TYPE = "UTF-8";
    
    /* ***********************************
     * Fields
     * ***********************************/
    private static Storage taskOrganiser;

    private File saveFile;
    private File configFile;
    private File userPrefFile;

    private String userPrefFileName;

    private BufferedReader reader;
    private PrintWriter writer;

    private Gson gson;

    /* ***********************************
     * Private constructor
     * ***********************************/
    private Storage() {
        gson = new Gson();

        saveFile = new File(SAVE_FILE_NAME);
        createIfNotExists(saveFile);

        configFile = new File(CONFIG_FILE_NAME);
        createIfNotExists(configFile);

        userPrefFileName = getUserPrefFileName(configFile);
        updateConfigFile(userPrefFileName);
        userPrefFile = new File(userPrefFileName);
        createIfNotExists(userPrefFile);
        
        MainApp.finiLogger.info("All files instantiated");
    }
    
    public static Storage getInstance() {
        if (taskOrganiser == null) {
            taskOrganiser = new Storage();
        }
        return taskOrganiser;
    }
    
    /* ***********************************
     * Public methods
     * ***********************************/
    public ArrayList<Task> readFile() {
        ArrayList<Task> tasks = new ArrayList<Task>();
        tasks = readTasks(userPrefFile);
        if (tasks == null || tasks.isEmpty()) {
            tasks = readTasks(saveFile);
            if (tasks == null || tasks.isEmpty()) {
                MainApp.finiLogger.info("Back up cannot save you!");
                tasks = new ArrayList<Task>();
            } else if (!tasks.isEmpty()) {
                MainApp.finiLogger.info("Main save file is damaged. Immediate back up plan is on!");
            }
        } else {
            MainApp.finiLogger.info("Successfully read file");
        }
        return tasks;
    }
    
    public String setUserPrefDirectory(String filePath) {
        userPrefFileName = filePath;
        File userFile = new File(userPrefFileName);

        if (userFile.equals(userPrefFile)) {
            return SAME_DIRECTORY_MESSAGE;
        } else if (userFile.exists()) {
            updateConfigFile(userPrefFileName);
            userPrefFile = userFile;
            return SET_SUCCESS_MESSAGE;
        } else {
            return SET_FAIL_MESSAGE;
        }
    }

    public boolean updateFile(ArrayList<Task> tasks) {
        return updateTasks(saveFile, tasks) && updateTasks(userPrefFile, tasks);
    }
    
    /* ***********************************
     * Private methods
     * ***********************************/
    private ArrayList<Task> readTasks(File file) {
        String text = EMPTY_STRING;
        ArrayList<Task> tasks = new ArrayList<Task>();
        try {
            if (!initReader(file)) {
                return tasks;
            }
            while ((text = reader.readLine()) != null) {
                Task task = gson.fromJson(text, Task.class);
                tasks.add(task);
            }
        } catch (IOException | JsonSyntaxException e) {
            e.printStackTrace();
            return null;
        }
        closeReader();
        return tasks;
    }

    private boolean updateTasks(File file, ArrayList<Task> tasks) {
        try {
            writer = new PrintWriter(file, FILE_ENCODING_TYPE);
            for (Task task : tasks) {
                writer.println(gson.toJson(task));
            }
        } catch (FileNotFoundException | UnsupportedEncodingException e) {
            e.printStackTrace();
            return false;
        }
        writer.close();
        return true;
    }

    private void updateConfigFile(String fileName) {
        try {
            writer = new PrintWriter(configFile, FILE_ENCODING_TYPE);
            writer.println(fileName);
            writer.close();
        } catch (FileNotFoundException | UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }

    /* ***********************************
     * Initialization methods
     * ***********************************/
    private boolean initReader(File saveFile) {
        try {
            reader = new BufferedReader(new FileReader(saveFile));
        } catch (FileNotFoundException e) {
            return false;
        }
        return true;
    }

    private void closeReader() {
        try {
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /* ***********************************
     * Utility methods
     * ***********************************/
    private void createIfNotExists(File file) {
        try {
            if (!file.exists()) {
                file.createNewFile();
                MainApp.finiLogger.info(file.toString() + " is created");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private String getUserPrefFileName(File configFile) {
        initReader(configFile);
        String fileName = EMPTY_STRING;
        try {
            if ((fileName = reader.readLine()) == null) {
                fileName = DEFAULT_USER_PREF_NAME;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        closeReader();
        return fileName;
    }
}
```
###### src/fini/main/model/Task.java
``` java
 */
public class Task implements TaskInterface {
    /* ***********************************
     * Constants
     * ***********************************/
    public static enum Type {
        DEFAULT, EVENT, DEADLINE
    }

    public static enum Priority {
        HIGH, MEDIUM, LOW, NORMAL
    }
    
    private static final String DEFAULT_PROJECT = "Inbox";

    /* ***********************************
     * Required fields
     * ***********************************/
    private String taskTitle;
    private boolean isRecurring;

    /* ***********************************
     * Optional fields
     * ***********************************/
    private String projectName;
    private Priority priority;
    private LocalDateTime taskStartDateTime = null;
    private LocalDateTime taskEndDateTime = null;
    private LocalDateTime recursUntil;
    private Period interval;

    private boolean isCompleted = false;
    private Type taskType;

    // ObjectID assign each Task instance a distinct ID
    // RecurUniqueID assign same ID for different Tasks under same recurring task
    private String objectID = null;
    private String recurUniqueID = null;

    /* ***********************************
     * TaskBuilder
     * ***********************************/
    public static class TaskBuilder {
        // Required
        private final String taskTitle;
        private final boolean isRecurring;

        // Optional
        private String projectName = DEFAULT_PROJECT;
        private Priority priority = Priority.NORMAL;
        private ArrayList<LocalDateTime> dateTimes = new ArrayList<LocalDateTime>();
        private LocalDateTime recursUntil = null;
        private Period interval = null;

        public TaskBuilder(String taskTitle, boolean isRecurring) {
            this.taskTitle = taskTitle;
            this.isRecurring = isRecurring;
        }

        public TaskBuilder setProjectName(String projectName) {
            this.projectName = projectName;
            return this;
        }

        public TaskBuilder setPriority(Priority priority) {
            this.priority = priority;
            return this;
        }

        public TaskBuilder setDatetimes(ArrayList<LocalDateTime> dateTimes) {
            this.dateTimes = dateTimes;
            return this;
        }

        public TaskBuilder setRecursUntil(LocalDateTime recursUntil) {
            this.recursUntil = recursUntil;
            return this;
        }

        public TaskBuilder setInterval(Period interval) {
            this.interval = interval;
            return this;
        }

        // Return a Task through build()
        public Task build() {
            return new Task(this);
        }
    }

    /* ***********************************
     * Private constructor
     * ***********************************/
    private Task(TaskBuilder taskBuilder) {
        // Required
        taskTitle = taskBuilder.taskTitle;
        isRecurring = taskBuilder.isRecurring;

        if (isRecurring) {
            recurUniqueID = UUID.randomUUID().toString();
        }

        objectID = UUID.randomUUID().toString();

        // Optional
        projectName = taskBuilder.projectName;
        priority = taskBuilder.priority;
        recursUntil = taskBuilder.recursUntil;
        interval = taskBuilder.interval;

        switch (taskBuilder.dateTimes.size()) {
            case 2:
                taskType = Type.EVENT;
                break;
            case 1:
                taskType = Type.DEADLINE;
                break;
            default:
                taskType = Type.DEFAULT;
                break;
        }

        switch (taskType) {
            case EVENT:
                taskStartDateTime = taskBuilder.dateTimes.get(0);
                taskEndDateTime = taskBuilder.dateTimes.get(1);
                break;
            case DEADLINE:
                taskStartDateTime = taskBuilder.dateTimes.get(0);
                break;
            default:
                break;
        }
    }
    
```
###### src/fini/main/model/TaskInterface.java
``` java
package fini.main.model;

/**
 * Task interface for Task class
 * It extends Cloneable which allows Task to be copied when executing undo and redo functions
 * 
 */
public interface TaskInterface extends Cloneable {
    public Task makeCopy();
}
```
###### src/fini/main/tests/StorageTest.java
``` java
 */

public class StorageTest {
	File saveFile = new File("save.txt");
	File configFile = new File("config.txt");
	File userPrefFile = new File("Fini_untitled.txt");
	File testFile = new File("/home/gaieepo/Videos/test.txt");
	
	PrintWriter writer;
	BufferedReader reader;

	@Test
	public void testStorageInit() {
		saveFile.delete();
		configFile.delete();
		userPrefFile.delete();

		Storage testStorage = Storage.getInstance();

		assertEquals(true, saveFile.exists());
		assertEquals(true, configFile.exists());
		assertEquals(true, userPrefFile.exists());
	}

	@Test
	public void testReadAndUpdateFile() {
		String[] data = {"curry chicken tomorrow morning project gai", 
				"gaieepo the day before the third sat of dec", 
		"harish tomorrow 5am repeat every two days priority high"};
		ArrayList<Task> inputData = createTasks(data);
		Storage testStorage = Storage.getInstance();
		assertEquals(true, testStorage.updateFile(inputData));
		ArrayList<Task> outputData = testStorage.readFile();
		compareTasks(inputData, outputData);
	}
	
	@Test
	public void testSetUserPrefDirectory() {
		Storage testStorage = Storage.getInstance();
		assertEquals("No such file", testStorage.setUserPrefDirectory("/home/gaieepo/Videos/test.txt"));
		
		if (!testFile.exists()) {
			try {
				testFile.createNewFile();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		// Directory tested is unique to different users
		assertEquals("The directory is set", testStorage.setUserPrefDirectory("/home/gaieepo/Videos/test.txt"));
		assertEquals("Same file directory", testStorage.setUserPrefDirectory("/home/gaieepo/Videos/test.txt"));
		assertEquals("No such file", testStorage.setUserPrefDirectory("/home/gaieepo/Videos/tes?t.txt"));
		assertEquals("No such file", testStorage.setUserPrefDirectory("/home/Videos/test.txt"));
	}
	
	@Test
	public void testBackUpSaveFile() {
		String[] data = {"curry chicken tomorrow morning project gai", 
				"gaieepo the day before the third sat of dec", 
		"harish tomorrow 5am repeat every two days priority high"};
		ArrayList<Task> inputData = createTasks(data);
		ArrayList<Task> outputData = new ArrayList<Task>();
		Storage testStorage = Storage.getInstance();
		assertEquals(true, testStorage.updateFile(inputData));
		
		// Spoil the userPrefFile
		try {
			writer = new PrintWriter(userPrefFile, "UTF-8");
			writer.println("Victory Draws Near!");
			writer.close();
		} catch (FileNotFoundException | UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		outputData = testStorage.readFile();
		compareTasks(inputData, outputData);
		
		// userPrefFile not found
		userPrefFile.delete();
		outputData = testStorage.readFile();
		compareTasks(inputData, outputData);
		
		try {
			writer = new PrintWriter(saveFile, "UTF-8");
			writer.println("Victory Draws Near!");
			writer.close();
		} catch (FileNotFoundException | UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		outputData = testStorage.readFile();
		assertEquals(true, outputData.isEmpty());
		
	}

	private ArrayList<Task> createTasks(String[] data) {
		FiniParser finiParser = FiniParser.getInstance();
		ArrayList<Task> tasks = new ArrayList<Task>();
		for (String taskString : data) {
			finiParser.parse(taskString);
			tasks.add(new Task.TaskBuilder(finiParser.getNotParsed(), finiParser.getIsRecurring())
					.setDatetimes(finiParser.getDatetimes())
					.setPriority(finiParser.getPriority())
					.setProjectName(finiParser.getProjectName())
					.setInterval(finiParser.getInterval())
					.setRecursUntil(finiParser.getRecursUntil()).build());
		}
		return tasks;
	}
	
	private void compareTasks(ArrayList<Task> inputData, ArrayList<Task> outputData) {
		for (int i = 0; i < outputData.size(); ++i) {
			assertEquals(inputData.get(i).getTitle(), inputData.get(i).getTitle());
			assertEquals(inputData.get(i).getTaskType(), inputData.get(i).getTaskType());
			assertEquals(inputData.get(i).isCompleted(), inputData.get(i).isCompleted());
			assertEquals(inputData.get(i).getStartDateTime(), inputData.get(i).getStartDateTime());
			assertEquals(inputData.get(i).getEndDateTime(), inputData.get(i).getEndDateTime());
			assertEquals(inputData.get(i).getPriority(), inputData.get(i).getPriority());
			assertEquals(inputData.get(i).getProjectName(), inputData.get(i).getProjectName());
		}
	}

	@After
	public void cleanUp() {
		saveFile.delete();
		configFile.delete();
		userPrefFile.delete();
		testFile.delete();
	}
}
```
###### src/fini/main/util/ModsLoader.java
``` java
 */
public class ModsLoader {
    /* ***********************************
     * Constants
     * ***********************************/
    private static final DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HHMM");

    /* ***********************************
     * Lessons
     * ***********************************/
    private ArrayList<Task> lessonTasks;

    public ModsLoader(File modsFile) {
        lessonTasks = new ArrayList<Task>();
        assert modsFile.exists();
        try {
            Document doc = Jsoup.parse(modsFile, "UTF-8");
            Elements lessons = doc.getElementsByClass("lesson");
            if (!lessons.isEmpty()) {
                for (Element lesson : lessons) {
                    String title = lesson.text();
                    LocalTime lessonStartTime = getTime(lesson.parent().className());
                    LocalTime lessonEndTime = getTime(lesson.parent().nextElementSibling().className());
                    LocalDate lessonDate = getDate(lesson.parent().parent().parent().id());
                    ArrayList<LocalDateTime> lessonDateTimes = new ArrayList<LocalDateTime>();
                    lessonDateTimes.add(LocalDateTime.of(lessonDate, lessonStartTime));
                    lessonDateTimes.add(LocalDateTime.of(lessonDate, lessonEndTime));
                    lessonTasks.add(new Task.TaskBuilder(title, true)
                            .setDatetimes(lessonDateTimes)
                            .setInterval(Period.ofWeeks(1)).build());
                }
                MainApp.finiLogger.info("Lessons are loaded");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /* ***********************************
     * Public getters
     * ***********************************/
    public ArrayList<Task> getLessonTasks() {
        return lessonTasks;
    }

    private LocalTime getTime(String lessonTime) {
        String temp = lessonTime.substring(1, 3) + lessonTime.substring(5);
        LocalTime time = LocalTime.parse(temp, timeFormatter);
        return time;
    }

    private LocalDate getDate(String lessonDate) {
        Parser parser = new Parser();
        List<DateGroup> groups = parser.parse(lessonDate);
        DateGroup group = groups.get(0);
        List<Date> dates = group.getDates();
        Date date = dates.get(0);
        LocalDate lessonLocalDate = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        return lessonLocalDate;
    }
}
```
